'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.changeDate = exports.formatGitDate = exports.getCommits = undefined;

var _moment = require('moment');

var _moment2 = _interopRequireDefault(_moment);

var _throwError = require('./errors/throwError');

var _throwError2 = _interopRequireDefault(_throwError);

var _gitLogConverter = require('./gitLogConverter');

var _gitLogConverter2 = _interopRequireDefault(_gitLogConverter);

var _execute = require('./execute');

var _execute2 = _interopRequireDefault(_execute);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_moment2.default.suppressDeprecationWarnings = true;

var getCommits = exports.getCommits = async function getCommits(path, _ref) {
  var count = _ref.count,
      hash = _ref.hash;

  var commitLog = void 0;

  if (hash) {
    commitLog = await (0, _execute2.default)('cd ' + path + ' && git log -1 -U ' + hash + ' --pretty');
  } else {
    commitLog = await (0, _execute2.default)('cd ' + path + ' && git log -n' + count + ' --pretty');
  }
  return (0, _gitLogConverter2.default)(commitLog);
};

var formatGitDate = exports.formatGitDate = function formatGitDate(date) {
  var momentDate = (0, _moment2.default)(date);
  if (!momentDate.isValid()) {
    (0, _throwError2.default)(new Error("DATE_INVALID"));
  }
  return momentDate.format('ddd MMM DD HH:mm:ss YYYY ZZ');
};

var changeDate = exports.changeDate = async function changeDate(path, hash, authorDate, committerDate) {
  try {
    var authorDateFormatted = formatGitDate(authorDate);
    var committerDateFormatted = formatGitDate(committerDate);

    return await (0, _execute2.default)('cd ' + path + ' && git filter-branch -f --env-filter     \'if [ $GIT_COMMIT = ' + hash + ' ]\n     then\n         export GIT_AUTHOR_DATE="' + authorDateFormatted + '"\n         export GIT_COMMITTER_DATE="' + committerDateFormatted + '"\n     fi\'');
  } catch (err) {
    return (0, _throwError2.default)(err);
  }
};